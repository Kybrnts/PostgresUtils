#!/bin/sh
#: Title       : Lastpostgreserrs
#: Date        : 2017-08-24
#: Authors     : Written by : "Kybernetes" <correodelkybernetes@gmail.com>
#:             : Reviewed by:  shd128 (https://github.com/shd128)
#: Version     : 1.0.0
#: Description : Dash script file
#:             : Retrieves last postgreSQL errors since last execution
#: Options     : N/A
##
## -- Required for execution -------------------------------------------------------------------------------------------
type awk >/dev/null || exit 1
type ps >/dev/null || exit 1
type fuser >/dev/null || exit 1
##
## -- Globals -----------------------------------------------------------------------------------------------------------
PGUSER=postgres                                          ## PostgreSQL's system user
PGVERS=9.5                                               ## PostgreSQL version (try to be version agnostic)
PGDATA=/var/lib/pgsql/$PGVERS/data                       ## PostgreSQL Databases container
PGLOGS="$PGDATA/pg_log"                                  ## PostgreSQL log files container
PGPIDF=/var/run/postgresql/pgsql.pid                     ## PostgreSQL external pidfile
_CNF_MATCHES="FATAL|ERROR"                               ## Error patterns to match in log files
_CNF_LSTLOGF="/home/monitor/lstpglog.log"                ## Last error count from log file
_CNF_LSTCNTF="/home/monitor/lstpgcount.log"              ## Last used log file
_CNF_NOWFRMT="%F"                                        ## Date's output format
_CNF_LOGFPFX=""                                          ## Fixed PostgreSQL logfile prefix
_CNF_LOGFSFX=".log"                                      ## Fixed PostgreSQL logfile suffix
##
## -- Auxiliary functions ----------------------------------------------------------------------------------------------
stdmsg() { #@ DESCRIPTION: Print messages to STDOUT
    #@ USAGE: stdmsg [ MSG ... ]
    [ "${1+X}" = X ] && printf "%s\n" "$@"
}
errmsg() { #@ DESCRIPTION: Print messages to STDERR prefixed by an error stamp
    #@ USAGE: stderr [ MSG ... ]
    stdmsg ${1+"Error! $@"} >&2
}
closeIFD() { #@ DESCRIPTION: Closes a FD. It Won't fail if FD is already disposed.
             #@ USAGE: closeFD FD
    eval "exec $1<&-"
}
_FFLNE=
getFFLne() { #@ DESCRIPTION: Reads 1st line of file specifided by $2 path into $1 name.
             #@ USAGE: getFFLne NAME PATH
    read _FFLNE <"$2"
    case $? in
        1) [ "X$_FFLNE" = "X" ] && return 1 ;; ## EOF reached before any EOL. If nothing was read, finish w/erros
        [!0]*) return 2 ;;                     ## Something went wrong
    esac
    eval "$1=\"\$_FFLNE\"" ## Assign global's value to referenced name  /!\ - $1 must be a valid shell name /!\
}
setFFLne() { #@ DESCRIPTION: Updates $1 file's first line with $2 string
             #@ USAGE: setFFLne PATH '[ STRING ]'
    stdmsg ${2+"$2"} >"$1" || return 1
}
##
## -- Core functions ---------------------------------------------------------------------------------------------------
_CHPIDS=
_CHPIDLST=
getChPidLst() { #@ DESCRIPTION: Gathers all $3-ID process child ids belonging to user whose name is $4 and that match $5
                #@              pattern in their command line, in a colon separated list. Then writes that list and the
                #@              number of gathered pids to $1 and $2 names respectively.
                #@ USAGE: getUsrPrcsPIDs NAME NAME PPID USER [ PATTERN ]
    _CHPIDLST=$(ps -eo "ppid ruser user pid args" | awk \
'BEGIN{ c=0; pidlist="" }
$1 == "'$3'" && ($2 == "'$4'" || $3 == "'$4'"){ # Filter 
    $1=$2=$3=""
    if($0 ~ /'"${5:-.*}"'/) {
        if(!c) pidlist=$4;
        else pidlist=pidlist":"$4;
        c++
    }
}
END{ print c"::"pidlist }
') || return 2                         ## Something nasty happened with awk or ps
    _CHPIDS=${_CHPIDLST%%::*}          ## Extract the number of elements from list prefix
    _CHPIDLST=${_CHPIDLST#$_CHPIDS::}  ## Remove list's prefix
    eval "$1=\"\$_CHPIDS\""            ## Assign global's value to referenced names /!\ - $1 must be a valid names /!\
    eval "$2=\"\$_CHPIDLST\""
    [ "$_CHPIDS" -gt 0 ] || return 1   ## Reurn 1 when no matching process is found
}
_MLNUM=
getMLnum() { #@ DESCRIPTION: Counts all matching lines from $2 file given the $3 pattern, storing number in $1 name.
             #@ USAGE: getMLnum NAME PATH [ PATTERN ]
    ## Count each matching line using awk w/inner variable, if awk fails let the calling environment know
    _MLNUM=$(awk 'BEGIN{ c=0 } /'"${3:-.*}"'/{ c++ } END{ print c }' "$2") || return 2
    ## Assign global's value to referenced name  /!\ - $1 must be a valid shell name /!\
    eval "$1=\"\$_MLNUM\""
    ## Also report to the calling environment when no matching lines are found 
    [ $_MLNUM -gt 0 ] || return 1
}
_MLNAFT=
dspMLnAft() { #@ DESCRIPTION: Displays $3 pattern-matching lines from $2 file, after (ignoring) first $4 matching ones.
              #@              Total number of read lines is saved into $1 name.
              #@ USAGE: dspLMLnsIf NAME PATH [ PATTERN [ NUM ] ]
    ## Proces $1 file, saving single awk's script STDOUT line to global, within subscript
    { _MLNAFT=$(awk \
'BEGIN{ c=0 }                     # Initialize line counter
/'"${3:-.*}"'/{                   # If line matches pattern..
    c++;                          # * Increase counter
    if(c > '${4:-0}') print "E"$0 # * If counter above ignored num, print line w/"E" prefix
}
END{ print "S"c - '${4:-0}' }     # Finally print total non-ignored lines number w/"S" prefix
' "$2" | while read -r line; do           ## Separate lines from STDIN using prefix untill EOF
            case $line in                 ## Remove prefix and send lines to..
                S*) stdmsg "${line#?}" ;; ## * STDOUT if S-prefixed so that only total maches is saved into global
                E*) errmsg "${line#?}" ;; ## * STDERR if E-prefixed so matching lines can be displayed
            esac
         done); } 2>&1 || return 2  ## Redirect STDERR messages to STDOUT where they belong. Return 2 if split fails
    eval "$1=\"\$_MLNAFT\""         ## Assign global's value to referenced names /!\ - $1 must be a valid names /!\
    [ $_MLNAFT -gt 0 ] || return 1  ## Return 1 when no matching lines where printed
}
##
## -- MAIN -------------------------------------------------------------------------------------------------------------
main() {
    set --
    ##
    ## 01.
    ##
    ## 02.
    ##
    ## 03.
    ##
    ## 04.
    ##
    ## 05.
    ##
    ## 06.
    ##
    ## 07.
    ##
    ## 08.
    ##
    ## 09.
    ##
    ## 10.
    ##
    ## 11.
    ##
    ## 12.
    ##
    ## 13.    
 }
##
## -- RUN! -------------------------------------------------------------------------------------------------------------
main "$@"
