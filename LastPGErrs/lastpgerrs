#!/bin/sh
#: Title       : Lastpostgreserrs
#: Date        : 2017-08-24
#: Authors     : Written by : "Kybernetes" <correodelkybernetes@gmail.com>
#:             : Reviewed by:  shd128 (https://github.com/shd128)
#: Version     : 1.0.0
#: Description : Dash script file
#:             : Retrieves last postgreSQL errors since last execution
#: Options     : N/A
##
## -- Required for execution -------------------------------------------------------------------------------------------
type awk >/dev/null || exit 1
type ps >/dev/null || exit 1
type fuser >/dev/null || exit 1
type file >/dev/null || exit 1
##
## -- Globals -----------------------------------------------------------------------------------------------------------
##
## Declare the following useful symbols:
readonly _NULL                              ## The unset value (null ptr), not to be confused w/the null string;
[ "$_SPC" ] || readonly _SPC="${IFS%??}"    ## Space (readonly uses a word for assignment's LHS);
[ "$_EOL" ] || readonly _EOL="${IFS#??}"    ## End of line;
[ "$_TAB" ] || { _TAB=${IFS%?}; readonly _TAB="${_TAB#?}"; } ## And the tab.
##
## Configuration parameters:
PGUSER=postgres                                          ## PostgreSQL's system user
PGVERS=9.5                                               ## PostgreSQL version (try to be version agnostic)
PGDATA=/var/lib/pgsql/$PGVERS/data                       ## PostgreSQL Databases container
PGLOGS="$PGDATA/pg_log"                                  ## PostgreSQL log files container
PGPIDF=/var/run/postgresql/pgsql.pid                     ## PostgreSQL external pidfile
_CNF_MATCHES="FATAL|ERROR"                               ## Error patterns to match in log files
_CNF_LSTLOGF="/home/monitor/lstpglog.log"                ## Last error count from log file
_CNF_LSTCNTF="/home/monitor/lstpgcount.log"              ## Last used log file
_CNF_NOWFRMT="%F"                                        ## Date's output format
_CNF_LOGFPFX=""                                          ## Fixed PostgreSQL logfile prefix
_CNF_LOGFSFX=".log"                                      ## Fixed PostgreSQL logfile suffix
##
## -- Auxiliary functions ----------------------------------------------------------------------------------------------
sbstr() { #@ DESCRIPTION: Tests if $1 is a substring fo $2
          #@ USAGE: sbstr '[ STRNG1 ]' '[ STRNG2 ]'
    case $2 in
        *$1*) return 0 ;;
    esac
    return 1
}
stdmsg() { #@ DESCRIPTION: Print messages to STDOUT
           #@ USAGE: stdmsg [ MSG ... ]
    [ "${1+X}" = X ] && printf "%s\n" "$@"
}
errmsg() { #@ DESCRIPTION: Print messages to STDERR prefixed by an error stamp
           #@ USAGE: stderr [ MSG ... ]
    stdmsg ${1+"Error! $@"} >&2
}
_FFLNE=
getFFLne() { #@ DESCRIPTION: Reads 1st line of file specified by $2 path into $1 name.
             #@ USAGE: getFFLne NAME PATH
    read _FFLNE <"$2"
    case $? in
        1) [ "X$_FFLNE" = "X" ] && return 1 ;; ## EOF reached before any EOL. If nothing was read, finish w/errors
        [!0]*) return 2 ;;                     ## Something went wrong
    esac
    eval "$1=\"\$_FFLNE\"" ## Assign global value to referenced name  /!\ - $1 must be a valid shell name /!\
}
setFFLne() { #@ DESCRIPTION: Updates $1 file's first line with $2 string
             #@ USAGE: setFFLne PATH '[ STRING ]'
    stdmsg ${2+"$2"} >"$1" || return 1
}
##
## -- Core functions ---------------------------------------------------------------------------------------------------
_UPIDCHS=   ## Number of elements of below string list 
_UPIDCHLST= ## User's process child list
getUPIDChLst() { #@ DESCRIPTION: Gathers all $3-ID process child ids belonging to user whose name is $4 and that match
                 #@              $5 pattern in their command line, in a colon separated list. Then writes that list and
                 #@              the number of gathered pids to $1 and $2 names respectively.
                 #@ USAGE: getUsrPrcsPIDs NAME NAME PPID USER [ PATTERN ]
     ## Get Parent pid, [r]user, pid and args of all currently running processes, then filter them out w/embedded awk
    _UPIDCHLST=$(ps -eo "ppid ruser user pid args" | awk \
'BEGIN{ c=0; pidlist="" }                                # Initialize a matches counter and a process id list
$1 == "'$3'" && ($2 == "'$4'" || $3 == "'$4'"){ # Filter # Filter out by parent PID and user
    $1=$2=$3=""                                          # Remove already matched fields
    if($0 ~ /'"${5:-.*}"'/) {                            # Match by pattern against args field
        if(!c) pidlist=$4;                               # Initialize begin pidlist
        else pidlist=pidlist":"$4;                       # Append to pidlist
        c++                                              # Increase matches counter
    }
}
END{ print c"::"pidlist }                                # Finally print list prefixed by its number of elements
') || return 2                           ## Return 2 if something nasty happened to pipeline
    _UPIDCHS=${_UPIDCHLST%%::*}          ## Extract the number of elements from list prefix
    _UPIDCHLST=${_UPIDCHLST#$_UPIDCHS::} ## Remove list's prefix
    eval "$1=\"\$_UPIDCHS\""             ## Write global child's num to $1 name /!\ - $1 must be a valid names /!\
    eval "$2=\"\$_UPIDCHLST\""           ## Write 
    [ "$_UPIDCHS" -gt 0 ] || return 1    ## Return 1 when no matching process is found
}
_BYPIDDIRTXFS=   ## Number of elements of below string list
_BYPIDDIRTXFLST= ## List of text files inside dir opened by PID
getByPIDDirTxFLst() { #@ DESCRIPTION: Gathers all txt files used by process whose ID is $3, contained right below $4 dir
                      #@              in a '\n' separated string list, in $2 name and storing the number of items in $1.
                      #@ USAGE: getByPIDDirFLst NAME NAME PID PATH
    ## Process all files within given dir, use \n as IFS to avoid word split on filenames w/spaces
    _BYPIDDIRTXFLST=$(IFS=$_EOL printf "%s\n" "$4"/* | {
            num=0 path= tpe= pids= ## A counter, current file path, type and processes IDs who are using it
            while read -r path; do                                               ## For each file..
                [ -f "$path" ] && tpe=$(file -i "$path" 2>/dev/null) || continue ## Skip if not a regular one
                if sbstr "text/plain" "$tpe"; then                               ## Skip if not a text one
                    pids=$(fuser -f "$path" 2>/dev/null) || continue             ## Get using PIDS, or skip if none
                    if sbstr $3 "$pids"; then                                    ## Skip if given PID not in using pids
                        stdmsg "$path"                                           ## If not skipped, send path to global
                        num=$((num + 1))                                         ## Increase counter
                    fi
                fi
            done                        
            stdmsg "$num"; }) || return 2               ## Put counter at end of global list. Also return 2 on pipe fail
    _BYPIDDIRTXFS=${_BYPIDDIRTXFLST##*"$_EOL"}          ## Get counter from STDOUT's last line (i.e. element of list)
    _BYPIDDIRTXFLST=${_BYPIDDIRTXFLST%"$_BYPIDDIRTXFS"} ## Remove list's last element (it is its dimension)
    _BYPIDDIRTXFLST=${_BYPIDDIRTXFLST%"$_EOL"}          ## 
    eval "$1=\"\$_BYPIDDIRTXFS\""                       ## Write list num. of elements to referenced name. MUST BE VALID
    eval "$2=\"\$_BYPIDDIRTXFLST\""                     ## Write list to referenced name. MUST BE A VALID NAME!!!
    [ $_BYPIDDIRTXFS -gt 0 ] || return 1                ## Return 1 when no files open in provided dir by provided PID
}
_MLNUM=
getMLnum() { #@ DESCRIPTION: Counts all matching lines from $2 file given the $3 pattern, storing number in $1 name.
             #@ USAGE: getMLnum NAME PATH [ PATTERN ]
    ## Count each matching line using awk w/inner variable, if awk fails let the calling environment know
    _MLNUM=$(awk 'BEGIN{ c=0 } /'"${3:-.*}"'/{ c++ } END{ print c }' "$2") || return 2
    ## Assign global's value to referenced name  /!\ - $1 must be a valid shell name /!\
    eval "$1=\"\$_MLNUM\""
    ## Also report to the calling environment when no matching lines are found 
    [ $_MLNUM -gt 0 ] || return 1
}
_MLNAFT=
dspMLnAft() { #@ DESCRIPTION: Displays $3 pattern-matching lines from $2 file, after (ignoring) first $4 matching ones.
              #@              Total number of read lines is saved into $1 name.
              #@ USAGE: dspLMLnsIf NAME PATH [ PATTERN [ NUM ] ]
    ## Proces $1 file, saving single awk's script STDOUT line to global
    { _MLNAFT=$(awk \
'BEGIN{ c=0 }                     # Initialize line counter
/'"${3:-.*}"'/{                   # If line matches pattern..
    c++;                          # * Increase counter
    if(c > '${4:-0}') print "E"$0 # * If counter above ignored num, print line w/"E" prefix
}
END{ print "S"c - '${4:-0}' }     # Finally print total non-ignored lines number w/"S" prefix
' "$2" |
        while read -r line; do            ## Split STDIN lines, sending them to STDOUT or ERR using prefix until EOF
            case $line in                 ## Remove prefix and send lines to..
                S*) stdmsg "${line#?}" ;; ## * STDOUT if S-prefixed so that only total matches is saved into global
                E*) errmsg "${line#?}" ;; ## * STDERR if E-prefixed so matching lines can be displayed
            esac
        done); } 2>&1 || return 2  ## Redirect STDERR messages to STDOUT where they belong. Return 2 if split fails
    eval "$1=\"\$_MLNAFT\""        ## Assign global's value to referenced names /!\ - $1 must be a valid names /!\
    [ $_MLNAFT -gt 0 ] || return 1 ## Return 1 when no matching lines where printed
}
##
## -- MAIN -------------------------------------------------------------------------------------------------------------
main() {
    set --
    ##
    ## Make sure that current user is postgres, otherwise finish w/errors (is this really necessary?)
    ##
    ## Read last log filename used by Logging Collector from file
    ##
    ## Read last number of matching lines found during previous run from file
    ##
    ## Count current number of matches found in previously used log file
    ##
    ## Compare the current number of errors "C" in previous log file w/the previous number "P"
    ##
    ## Update last number of matches found in previous run in file adding "C - P" to its number
    ##
    ## Find PostgreSQL's Logging collector's PID
    ##
    ## Get current log filename used by Logging Collector
    ##
    ## Compare currently used log file w/read one
    ##
    ## Now Collector's using new log file since previous run, so create/update last file log file
    ##
    ## Count all matching lines found in new log file, finishing w/errors if that fails
    ##
    ## Display previously counted matching lines from new log file
    ##
    ## Update last number of matches found in previous run in file w/counted number
 }
##
## -- RUN! -------------------------------------------------------------------------------------------------------------
main "$@"
